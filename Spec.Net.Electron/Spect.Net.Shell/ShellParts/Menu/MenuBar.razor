@{
    // This component is responsible to display the menu bar of the application and manage
    // all keyboard and mouse events that control the menu behavior.
}

@inherits StateAwareComponentBase
@inject IThemingService<ThemeProps> ThemingService
@inject IFocusManagerService FocusManagerService

<div class="menu-bar" tabindex="0">
    @{
        var menuState = AppState?.MenuState;
        if (menuState?.AppMenu != null)
        {
            var appMenu = menuState.AppMenu;
            // --- Display the top-level menu items as MenuButtons
            for (var i = 0; i < appMenu.Items.Count; i++)
            {
                var menuItem = appMenu.Items[i];
                <MenuButton Item="@menuItem"
                            Index="@i"
                            ComponentInstanceID="@ButtonId(i)"
                            Highlight="menuState.HighlightAccessKeys"
                            TitleColor="@_titleColor"
                            Pointed="@(menuState.SelectedIndex == i)"
                            BoundariesChanged="OnBoundariesChanged" />
            }

            // --- Display the list of open menu panes
            <MenuPaneList Panes="@menuState.OpenPanes"
                          HighLight="menuState.HighlightAccessKeys"
                          MenuItemPointed="OnMenuItemPointed"
                          MenuItemClicked="OnMenuItemClicked" />
        }
    }
</div>

@code {
    // --- Store the color of the title (it's different for focused/unfocused state)
    private string _titleColor;

    // --- To display menu paned, we need to keep track of menu button boundaries
    private readonly Dictionary<string, ElementBoundaries> _boundaries =
        new Dictionary<string, ElementBoundaries>();

    // --- Shows the pane index to remove
    private int _delayedRemove;

    /// <summary>
    /// Turns on listening to FocusManager events
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        FocusManagerService.AppKeyDown += OnKeyDown;
        FocusManagerService.AppKeyUp += OnKeyUp;
    }

    /// <summary>
    /// Turns off listening to FocusManager events
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        FocusManagerService.AppKeyDown -= OnKeyDown;
        FocusManagerService.AppKeyUp -= OnKeyUp;
    }

    /// <summary>
    /// Respons to application state changes
    /// </summary>
    protected override void OnStateChanged(AppState prevState, AppState newState)
    {
        CalculateColors(newState.HasFocus);
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Calculate MenuBar color according to focused/unfocused state
    /// </summary>
    /// <param name="hasFocus"></param>
    private void CalculateColors(bool hasFocus)
    {
        _titleColor = ThemingService.GetProperty(s =>
            hasFocus ? s.TitleBarActiveColor : s.TitleBarInactiveColor);
    }

    /// <summary>
    /// Store the boundaries of a particular menu button
    /// </summary>
    private void OnBoundariesChanged(BoundariesEventArgs args)
    {
        if (args.ComponentId != null)
        {
            _boundaries[args.ComponentId] = args.Boundaries;
        }
    }

    /// <summary>
    /// Gets the ID of the specified menu button
    /// </summary>
    private string ButtonId(int index) => $"MenuButton{index}";

    /// <summary>
    /// Shortcut to the app's menu state
    /// </summary>
    private AppMenuState MenuState => AppState.MenuState;


    /// <summary>
    /// Listen to keydown events to implement menu navigation
    /// </summary>
    private void OnKeyDown(object sender, KeyboardEventArgs args)
    {
        Console.WriteLine($"KeyDown: {args.Code}");

        // --- Set the pointed state of the menu bar
        if (args.Code == "AltLeft") Dispatch(new MenuAltPressedAction());

        // --- No button is pointed, no more action 
        if (MenuState.SelectedIndex < 0) return;

        // --- From this point on, we use the keyboard.
        // --- Here, we allow the mouse to delay submenu removal.
        _delayedRemove = -1;
        if (args.Code == "Escape")
        {
            Dispatch(new MenuPaneClosedAction());
            return;
        }

        // --- Move one step to left, or close the last pane.
        if (args.Code == "ArrowLeft") {
            if (MenuState.OpenPanes.Count > 1)
            {
                // --- Close the last pane
                Dispatch(new MenuPaneClosedAction());
                return;
            }

            // --- Move to the left
            var index = MenuState.SelectedIndex - 1;
            if (index < 0) index = MenuState.AppMenu.Items.Count - 1;

            // --- Open the pane of the current menu button
            var pane = MenuState.OpenPanes.Count > 0
                ? GetButtonPane(index)
                : null;
            Dispatch(new MenuButtonSetAction(index, pane, true));
            return;
        }

        // --- Move one step to right, or open a submenu pane.
        if (args.Code == "ArrowRight") {
            // --- Try to open the submenu of the current item and complete if succeeded
            // TODO: Implement this

            // --- We're not in the first menu pane
            if (MenuState.OpenPanes.Count > 1)
            {
                return;
            }

            // --- We're in the first menu pane, move to the right
            var index = MenuState.SelectedIndex + 1;
            if (index > MenuState.AppMenu.Items.Count - 1) index = 0;

            // --- Open the pane of the current menu button
            var pane = MenuState.OpenPanes.Count > 0
                ? GetButtonPane(index)
                : null;
            Dispatch(new MenuButtonSetAction(index, pane, true));
            return;
        }

        // --- Move one step down, or open the pane of a button
        if (args.Code == "ArrowDown")
        {
            if (MenuState.OpenPanes.Count == 0)
            {
                var index = MenuState.SelectedIndex;
                Dispatch(new MenuButtonSetAction(index, GetButtonPane(index), true));
            }
            else
            {
                Dispatch(new MenuItemDownAction());
            }
            return;
        }

        // --- Move one step down in the current open pane
        if (args.Code == "ArrowUp")
        {
            Dispatch(new MenuItemUpAction());
            return;
        }
    }

    /// <summary>
    /// Listen to keydown events to implement menu navigation
    /// </summary>
    private void OnKeyUp(object sender, KeyboardEventArgs args)
    {
        if (args.Code == "AltLeft")
        {
            Dispatch(new MenuAltReleasedAction());
        }
    }

    /// <summary>
    /// Respond to the event when an item on a displayed menu pane is pointed.
    /// </summary>
    private void OnMenuItemPointed(MenuItemEventArgs item)
    {
    }

    /// <summary>
    /// Respond to the event when an item on a displayed menu pane is clicked
    /// </summary>
    private void OnMenuItemClicked(MenuItemEventArgs item)
    {
    }

    /// <summary>
    /// Gets the information about the specified menu pane
    /// </summary>
    /// <param name="index">MenuButton index</param>
    private MenuPaneInfo GetButtonPane(int index)
    {
        MenuPaneInfo pane = null;
        if (_boundaries.TryGetValue(ButtonId(index), out var boundary))
        {
            pane = new MenuPaneInfo
            {
                ParentIndex = -1,
                SelectedIndex = -1,
                Items = MenuState.AppMenu.Items[index].Items,
                LeftPos = boundary.OffsetLeft,
                TopPos = boundary.OffsetTop + boundary.OffsetHeight
            };
            if (MenuState.KeyboardAction)
            {
                SetFirstMenuItemIndex(pane);
            }
        }
        return pane;
    }

    /// <summary>
    /// Sets the index of the first available menu item within the pane.
    /// </summary>
    /// <param name="pane"></param>
    private void SetFirstMenuItemIndex(MenuPaneInfo pane)
    {
        var items = pane.Items;
        var selectedIndex = -1;
        var index = 0;
        foreach(var item in pane.ItemsFlattened)
        {
            if (item.Visible && item.Enabled)
            {
                selectedIndex = index;
                break;
            }
            index++;
        }
        pane.SelectedIndex = selectedIndex;
    }
}
