@{
    // This component is responsible to display the menu bar of the application and manage
    // all keyboard and mouse events that control the menu behavior.
}

@inherits StateAwareComponentBase
@inject IThemingService<ThemeProps> ThemingService
@inject IFocusManagerService FocusManagerService

<div class="menu-bar" tabindex="0">
    @{
        var menuState = AppState?.MenuState;
        if (menuState?.AppMenu != null)
        {
            var appMenu = menuState.AppMenu;
            // --- Display the top-level menu items as MenuButtons
            for (var i = 0; i < appMenu.Items.Count; i++)
            {
                var menuItem = appMenu.Items[i];
                <MenuButton Item="@menuItem"
                            Highlight="menuState.HighlightAccessKeys"
                            TitleColor="@_titleColor"
                            Pointed="@(menuState.SelectedIndex == i)"
                            BoundariesChanged="OnBoundariesChanged" />
            }

            // --- Display the list of open menu panes
            <MenuPaneList Panes="@menuState.OpenPanes"
                          HighLight="menuState.HighlightAccessKeys"
                          MenuItemPointed="OnMenuItemPointed"
                          MenuItemClicked="OnMenuItemClicked" />
        }
    }
</div>

@code {
    // --- Store the color of the title (it's different for focused/unfocused state)
    private string _titleColor;

    // --- To display menu paned, we need to keep track of menu button boundaries
    private readonly Dictionary<MenuButton, ElementBoundaries> _boundaries =
        new Dictionary<MenuButton, ElementBoundaries>();

    // --- Shows the pane index to remove
    private int _delayedRemove;

    /// <summary>
    /// Turns on listening to FocusManager events
    /// </summary>
    protected override void OnInitialized()
    {
        base.OnInitialized();
        FocusManagerService.AppKeyDown += OnKeyDown;
        FocusManagerService.AppKeyUp += OnKeyUp;
    }

    /// <summary>
    /// Turns off listening to FocusManager events
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        FocusManagerService.AppKeyDown -= OnKeyDown;
        FocusManagerService.AppKeyUp -= OnKeyUp;
    }

    /// <summary>
    /// Respons to application state changes
    /// </summary>
    protected override void OnStateChanged(AppState prevState, AppState newState)
    {
        CalculateColors(newState.HasFocus);
        InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Calculate MenuBar color according to focused/unfocused state
    /// </summary>
    /// <param name="hasFocus"></param>
    private void CalculateColors(bool hasFocus)
    {
        _titleColor = ThemingService.GetProperty(s =>
            hasFocus ? s.TitleBarActiveColor : s.TitleBarInactiveColor);
    }

    /// <summary>
    /// Store the boundaries of a particular menu button
    /// </summary>
    private void OnBoundariesChanged(BoundariesEventArgs args)
    {
        var menuButton = args.Component as MenuButton;
        if (menuButton != null)
        {
            _boundaries[menuButton] = args.Boundaries;
        }
    }

    private AppMenuState MenuState => AppState.MenuState;

    /// <summary>
    /// Listen to keydown events to implement menu navigation
    /// </summary>
    private void OnKeyDown(object sender, KeyboardEventArgs args)
    {
        Console.WriteLine($"KeyDown: {args.Code}");

        // --- Set the pointed state of the menu bar
        if (args.Code == "AltLeft") Dispatch(new MenuAltPressedAction());

        // --- No button is pointed, no more action 
        if (MenuState.SelectedIndex < 0) return;

        // --- From this point on, we use the keyboard.
        // --- Here, we allow the mouse to delay submenu removal.
        _delayedRemove = -1;
        if (args.Code == "Escape")
        {
            Dispatch(new MenuPaneClosedAction());
            return;
        }

        // --- Move one step to left, or close the last pane.
        if (args.Code == "ArrowLeft") {
            if (MenuState.OpenPanes.Count > 1)
            {
                // --- Close the last pane
                Dispatch(new MenuPaneClosedAction());
                return;
            }

            // --- Move to the left
            var index = MenuState.SelectedIndex - 1;
            if (index < 0) index = MenuState.AppMenu.Items.Count - 1;

            // --- Open the pane of the current menu button
            // TODO: Implement this
            Dispatch(new MenuButtonSetAction(index, null, true));
            return;
        }

        // --- Move one step to right, or open a submenu pane.
        if (args.Code == "ArrowRight") {
            // --- Try to open the submenu of the current item and complete if succeeded
            // TODO: Implement this

            // --- We're not in the first menu pane
            if (MenuState.OpenPanes.Count > 1)
            {
                return;
            }

            // --- We're in the first menu pane, move to the right
            var index = MenuState.SelectedIndex + 1;
            if (index > MenuState.AppMenu.Items.Count - 1) index = 0;

            // --- Open the pane of the current menu button
            // TODO: Implement this

            Dispatch(new MenuButtonSetAction(index, null, true));
            return;
        }

    }

    /// <summary>
    /// Listen to keydown events to implement menu navigation
    /// </summary>
    private void OnKeyUp(object sender, KeyboardEventArgs args)
    {
        if (args.Code == "AltLeft")
        {
            Dispatch(new MenuAltReleasedAction());
        }
    }

    /// <summary>
    /// Respond to the event when an item on a displayed menu pane is pointed.
    /// </summary>
    private void OnMenuItemPointed(MenuItemEventArgs item)
    {
    }

    /// <summary>
    /// Respond to the event when an item on a displayed menu pane is clicked
    /// </summary>
    private void OnMenuItemClicked(MenuItemEventArgs item)
    {
    }
}
